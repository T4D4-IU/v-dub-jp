---
trigger: always_on
---

# プロジェクト概要
動画および音声コンテンツ（YouTube以外の要ログインサイト含む）をインプットとし、日本語の吹き替え版を自動生成して管理・視聴できるプラットフォームのバックエンドおよびワーカーを開発する。

# 開発の基本原則

## TDD原則
- 常にTDDサイクル（Red → Green → Refactor）に従う。
- 最も単純な失敗するテストを最初に書く。
- テストが通るために必要最低限のコードだけ実装する。
- テストが通った後にのみリファクタリングを行う。
- `plan.md` の指示に従い、指定された次のテストを実装する。

## ROP (Railway Oriented Programming) の実践
- エラーを例外としてではなく、プログラムフローの中核部分として型レベルで扱う。
- すべての関数は成功または失敗を必ず返す。例外（`panic!` や `unwrap()`）はプログラマエラーや回復不可能な状況でのみ使用する。
- `thiserror` を用いてドメインごとのエラー型（enum）を定義し、コンテキスト情報を含める。
- `anyhow` はアプリケーションの最上位層（APIハンドラなど）でのみ動的エラーハンドリングとして使用する。
- `and_then`, `map`, `map_err`, `?` 演算子を活用し、ハッピーパスとエラーパスを分離した処理チェーンを構築する。

## Observability (可観測性) の確保
- `tracing` および `tracing-subscriber` クレートを使用して構造化ログを出力する。
- 単なる `println!` や `log` クレートは使用しない。
- 重要な処理（APIリクエストの受信、外部プロセス起動、AI推論、DB操作など）には必ず `#[tracing::instrument]` マクロを付与し、Span（処理の境界と引数情報）を自動記録する。
- エラー発生時には、根本原因が追跡できるように `tracing::error!` でエラーコンテキストを記録する。

## Rust特化の関数型プログラミング原則
- イテレータチェーン（`map`, `filter`, `fold`）を活用し、宣言的なデータ変換パイプラインを構築する。
- 所有権システムを活用し、不要な `Clone` を避ける。可能な限り借用（`&`）を使用する。
- `let`（不変）を基本とし、`mut` は必要最小限に抑える。
- トレイトによる抽象化を行い、単一責任原則を守る。

# 技術スタックと実装要件
- 言語: Rustのみ使用（Pythonは禁止）
- バックエンドAPI: `axum`
- 非同期ランタイム: `tokio`
- 外部API呼び出し: `reqwest`
- メディア処理: `yt-dlp` (外部プロセスとして `tokio::process::Command` 等で呼び出し)、`FFmpeg`
- AI推論: `candle`, `burn` 等のローカル推論、または各種外部API

# コミットと品質基準
コミットは以下を満たした場合のみ行う：
1. `cargo test` がすべてパスしている。
2. `cargo check` と `cargo clippy` が警告なしで完了する。
3. `cargo fmt` でコードフォーマットが適用されている。

コードを変更した後は、必ず `cargo test` と `cargo clippy` を実行して問題がないことを確認すること。